<!DOCTYPE html>

<!--
Some explanations:

 - In development mode, each page selected is composed of a pair containing the
   top and left menus separated by a underscore. For example, if the user selects
   "Motherboard" and "debug", all sections will be hidden except for "mboard_debug".
   The code that does this is in "page.js", in the method `updatePage()`.
 - Some sections will be built dynamically by javascript. This is mostly true
   about the "debug" sections. The code that builds these sections is in
   "page.js", in the method `initializePage()`.
 - A special <span class="memory_data"> is a widget that, managed by javascript code,
   allows edition and direct access to the emulated computer memory.
 - A special <span class="memory_table"> is a widget that, managed by javascript code,
   presents a memory table and optionally allows editing.
-->

<html>
  <meta charset="utf-8">
  <link rel="stylesheet" href="tinyvm.css">
  
  <!-- management code -->
  <script src="src/page/util.js"></script>
  <script src="src/page/memorydata.js"></script>
  <script src="src/page/memorytable.js"></script>
  <script src="src/page/tests.js"></script>

  <!-- emulator code -->
  <script src="src/tinyvm/motherboard.js"></script>
  <script src="src/tinyvm/ram.js"></script>
  <script src="src/tinyvm/bios.js"></script>
  <script src="src/tinyvm/mmu.js"></script>
  <script src="src/tinyvm/tinyvm.js"></script>

  <script src="src/page/page.js"></script>

  <title>tinyvm 0.0.1</title>

  <body>
    <header>
      tinyvm 0.0.1
      <hr>
    </header>

    <!--          -->
    <!-- COMPUTER -->
    <!--          -->

    <section id="computer">
      <span id="loading"><p>Loading...</p></span>
      <section id="screen"></section>
      <section id="choose_dev_mode" class="dev_mode">
        <label>
          <input type="checkbox" id="dev_mode" onchange="page.developmentModeUpdated(this.checked);">Development mode
        </label>
      </section>
    </section>

    <!--       -->
    <!-- MENUS -->
    <!--       -->

    <section id="dev" class="development">

      <nav id="topmenu" class="topmenu">
        <span onclick="page.menuSelected(this.id);" id="doc" class="selected">doc</span>
        <span onclick="page.menuSelected(this.id);" id="debug">debug</span>
        <span onclick="page.menuSelected(this.id);" id="test">test</span>
      </nav>

      <nav id="leftmenu" class="leftmenu">
        <span onclick="page.menuSelected(this.id);" id="mboard">Motherboard</span>
        <span onclick="page.menuSelected(this.id);" id="ram">RAM</span>
        <span onclick="page.menuSelected(this.id);" id="bios">BIOS</span>
        <span onclick="page.menuSelected(this.id);" id="mmu">MMU</span>
        <span onclick="page.menuSelected(this.id);" id="about" class="selected">About</span>
      </nav>

      <!--          -->
      <!-- CONTENTS -->
      <!--          -->

      <section id="content" class="content">

        <!--            -->
        <!-- ABOUT PAGE -->
        <!--            -->
        <section id="about_doc">
          <p><b>tinyvm</b> is a emulator for a 32-bit computer that aims to be 
            as powerful as a modern computer, but as simple as 8-bit computer
            from the 80s. This computer doesn't exist in a physical form 
            (<i>yet</i>).</p>
          <p>Features:</p>
          <ul>
            <li>32-bit CPU</li>
            <li>up to 4 Gb of RAM</li>
            <li>virtual memory</li>
            <li>up to 4 hard disks of 256 Gb each</li>
          </ul>
          <p>The tab "<i>doc</i>" contains the documentation for each one of the 
            computer devices on the left. The tab "<i>debug</i>" allows the 
            internals of each device to be inspected.</p>
          <p>The code for this emulator is avaliable under the
            <a href="LICENSE">GPLv3 license</a>.</p>
        </section>

        <section id="not_avaliable">Not avaliable.</section>

        <!--             -->
        <!-- MOTHERBOARD -->
        <!--             -->

        <section id="mboard_doc">
          <h2>Motherboard</h2>
          <p>The <b>motherboard</b> coordinates how the memory is accessed. Each <b>device</b>
            contains an addressing area, and the motherboard will relay the information
            to the device, according to the address.</p>
          <p>The addressing areas are organized in a <b>memory map</b>.</p>
          <p>The full physical memory of the computer (<b>RAM</b>) is also present
            in the motherboard. When a memory address is accessed, the motherboard will:</p>
          <ol>
            <li>look for a device in the memory map. If no device is mapped to this address, it will</li>
            <li>ask the MMU for a physical address. If the MMU is not active, it will</li>
            <li>access the physical address in RAM. If the address is out of bounds, it will</li>
            <li>set the <b>OB</b> (<i>out of bounds</i>) register. This register can be accessed
              at 0xFFFFFFFF.</li>
          </ol>
          <p>This means that, without a MMU active, the memory map will look like this:</p>
          <table class="mmap">
            <tr>
              <td class="area ram">RAM (physical memory)</td>
              <td class="beginning"></td>
              <td class="address">0x00000000</td>
            </tr>
            <tr>
              <td class="area invalid">Invalid access area</td>
              <td class="beginning"></td>
              <td class="address">?? (depending on memory size)</td>
            </tr>
            <tr>
              <td class="area devreg">Devices registers</td>
              <td class="beginning"></td>
              <td class="address">0xF0000000</td>
            </tr>
            <tr>
              <td class="area devram">Devices RAM</td>
              <td class="beginning"></td>
              <td class="address">0xF0010000</td>
            </tr>
            <tr>
              <td class="area ob">OB</td>
              <td class="beginning"></td>
              <td class="address">0xFFFFFFFF</td>
            </tr>
          </table>

          <h2>Implementing new devices</h2>
          <p>New devices can be created in javascript and connected to the motherboard.
            For that, they need to respect the following interface:</p>
          <pre class="code">
class Device {
    constructor(interrupts...)
    name()            : string
    interruptCount()  : int         [optional]
    get(addr)         : uint8_t
    set(addr, uint_8)
    avaliable()       : bool
    doc()             : html_string [optional]
    debug()           : html_string [optional]
}
          </pre>
          <p>Devices of this kind will receive 256 bytes of area to use as registers.</p>
          <p>Devices can also request an extra, larger amount of memory
             to be used as a local RAM. These devices need to respect the following interface:</p>
          <pre class="code">
class RAMDevice extends Device {
    areaRequested() : int
    getRAM(addr)    : uint8_t
    setRAM(addr, uint8_t)
} 
          </pre>
          <p>The MMU is a special kind of devices that manages virtual memory
             addresses. There can be only one MMU attached to the motherboard,
             and it follows this interface:</p>
          <pre class="code">
class MMU extends Device {
    translate(uint32_t) : uint32_t
}
          </pre>
        </section>

        <section id="mboard_debug">

          <h2>Memory map</h2>
          <section id="mmap"></section>

          <h2>Registers</h2>
          <section id="registers">
            <table>
              <tr>
                <th>Register</th>
                <th>Description</th>
                <th>Address</th>
                <th>Current value</th>
              </tr>
              <tr>
                <td class="register">OB</td>
                <td>
                  <b>Out of bounds.</b>
                  Set to 1 when an access was made to a memory address outside of bounds.
                  Needs to be reset to 0 manually.
                </td>
                <td>0xFFFFFFFF</td>
                <td class="value"><span class="memory_data">0xFFFFFFFF,2,prefix,rw</span></td>
              </tr>
            </table>
          </section>

        </section>

        <section id="mboard_test">
          <button class="test" onclick="(new Motherboard()).runTests('mboard_tests');">Run tests</button>
          <section id="mboard_tests"></section>
        </section>

        <!--     -->
        <!-- RAM -->
        <!--     -->

        <section id="ram_doc">
          <h2>RAM</h2>
          <p>The RAM (random access memory) store the information used by the programs running in the computer.</p>
          <p>It is important to notice that the RAM is never accessed directly. The motherboard will determine the address,
             usually following these rules:</p>
          <ol>
            <li>If the address is &ge; <b>0xF0000000</b>, the access is redirected to the devices;</li>
            <li>If the address is &lt; <b>0xF0000000</b> and virtual memory is <b>active</b>, 
                the address is rerouted via the MMU;</li>
            <li>If the address is &lt; <b>0xF0000000</b> and virtual memory is <b>not active</b>, 
                then the address is accessed directly in the RAM.</li>
          </ol>
          <p>When the memory is being accessed directly (option 3), the RAM is also called <b>physical memory</b>.</p>
        </section>

        <section id="ram_debug">
        </section>

        <section id="ram_test">
          <button class="test" onclick="(new RAM(4)).runTests('ram_tests');">Run tests</button>
          <section id="ram_tests"></section>
        </section>

        <!--      -->
        <!-- BIOS -->
        <!--      -->

        <section id="bios_doc">
          <h2>BIOS</h2>
          <p>The BIOS is a read-only block of memory that is the first code 
             executed when the computer is turned on.</p>
          <p>It contains code that will check errors and look for disks present, 
             loading the booting code and excuting it.</p>
          <p>When the CPU is turned on, it will point to <b>0xF0000000</b>, (in the BIOS
             area), that will contain simply a jump to a larger code area starting in
             <b>0xF0010000</b>.</p>
        </section>

        <section id="bios_debug">
          <h2>Registers</h2>
          <section id="registers">
            <table>
              <tr>
                <th>Register</th>
                <th>Description</th>
                <th>Address</th>
                <th>Current value</th>
              </tr>
              <tr>
                <td class="register"></td>
                <td>Jumps to beginning of BIOS code. (jmp 0xF0010000)</td>
                <td>0xF0000000</td>
                <td class="value">
                  <span class="memory_data">0xF0000000,2,rw</span>
                  <span class="memory_data">0xF0000001,2,rw</span>
                  <span class="memory_data">0xF0000002,2,rw</span>
                  <span class="memory_data">0xF0000003,2,rw</span>
                  <span class="memory_data">0xF0000004,2,rw</span>
                </td>
              </tr>
              <tr>
                <td class="register">BMIN</td>
                <td>BIOS version (minor)</td>
                <td>0xF0000010</td>
                <td class="value"><span class="memory_data">0xF0000010,2,prefix,rw</span></td>
              </tr>
              <tr>
                <td class="register">BMAJ</td>
                <td>BIOS version (major)</td>
                <td>0xF0000011</td>
                <td class="value"><span class="memory_data">0xF0000011,2,prefix,rw</span></td>
              </tr>
            </table>
          </section>

          <h2>Source code</h2>
          <section id="bios_source"></section>

          <h2>Binary data</h2>
          <section class="memory_table">0xF0010000,0xF001FFFF</section>

        </section>

        <!--     -->
        <!-- MMU -->
        <!--     -->
        <section id="mmu_doc">
          <h2>MMU</h2>
          <p>The MMU (memory management unit) controls the access to the RAM. 
             If the MMU is <b>disabled</b>, any memory address is mapped
             directly to the same adress in RAM (this is called 
             <b><i>physical memory</i></b>). If the MMU is <b>enabled</b>, however,
             a memory access to any address is translated by the MMU. This allows
             for more sophisticated memory management technique called <b>virtual 
             memory</b>.</p>

          <h2>Virtual Memory</h2>
          <p>It is possible to activate the memory indirectly through <b>virtual 
             memory</b>. In this case, the MMU will access the memory indirectly. 
             When the CPU request a memory byte from the MMU, the MMU will lookup 
             the position in a page table to search for the physical position. 
             This has the following advantages:</p>
          <ul>
            <li>By creating several page tables, it is possible to make that several 
                processes see the full memory as if were their own, easing the 
                development and avoiding that processes access memory from other 
                processes;</li>
            <li>It is possible to establish different permissions for different 
                memory pages. A page, for example, might be only accessible by the kernel;</li>
            <li>It is possible to create pages outside of the memory, thus allowing more 
                memory to be addressable than what is available in the device.</li>
          </ul>

          <h2>Memory address translation</h2>
          <p>The image below illustrates how the logical access works. The VMEM register 
             contains the <b>Page directory</b> address. The page directory points 
             to multiple page tables, and the page table points to a page in memory.</p>
          <img alt="VMEM register" src="img/vmem.png">

        </section>
      </section>

    </section>


    <footer>
      <hr>
      Released under the <a href="LICENSE">GPLv3 license</a>.<br>
      Tested on the latest version of
      <a href="https://www.google.com/chrome/">Google Chrome</a><!-- and
      <a href="https://www.mozilla.org/firefox/">Mozilla Firefox</a>-->.
    </footer>
  </body>
</html>

<!-- vim: ts=2:sw=2:sts=2:expandtab
-->
