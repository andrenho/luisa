<!DOCTYPE html>

<!--
Some explanations:

 - In development mode, each page selected is composed of a pair containing the
   top and left menus separated by a underscore. For example, if the user selects
   "Motherboard" and "debug", all sections will be hidden except for "mboard_debug".
   The code that does this is in "page.js", in the function `updatePage()`.
 - Some sections will be built dynamically by javascript. This is mostly true
   about the "debug" sections. The code that builds these sections is in
   "page.js", in the function `initializePage()`.
 - A special <span class="memory_data"> is a widget that, managed by javascript code,
   allows edition and direct access to the emulated computer memory.
-->

<html>
  <meta charset="utf-8">
  <link rel="stylesheet" href="tinyvm.css">
  
  <!-- management code -->
  <script src="util.js"></script>
  <script src="memory_data.js"></script>
  <script src="page.js"></script>
  <script src="tests.js"></script>
  <script src="memorydebugger.js"></script>

  <!-- emulator code -->
  <script src="bios.js"></script>
  <script src="motherboard.js"></script>

  <title>tinyvm 0.0.1</title>

  <body>
    <header>
      tinyvm 0.0.1
      <hr>
    </header>

    <!--          -->
    <!-- COMPUTER -->
    <!--          -->

    <section id="computer">
      <section id="screen"></section>
      <label>
        <input type="checkbox" id="dev_mode" onchange="update_dev_mode(this.checked);">Development mode
      </label>
    </section>

    <!--       -->
    <!-- MENUS -->
    <!--       -->

    <section id="dev" class="development">

      <nav id="topmenu" class="topmenu">
        <span onclick="menu(this.id);" id="doc" class="selected">doc</span>
        <span onclick="menu(this.id);" id="debug">debug</span>
        <span onclick="menu(this.id);" id="test">test</span>
      </nav>

      <nav id="leftmenu" class="leftmenu">
        <span onclick="menu(this.id);" id="mboard">Motherboard</span>
        <span onclick="menu(this.id);" id="about" class="selected">About</span>
      </nav>

      <!--          -->
      <!-- CONTENTS -->
      <!--          -->

      <section id="content" class="content">

        <!--            -->
        <!-- ABOUT PAGE -->
        <!--            -->
        <section id="about_doc">
          <p><b>tinyvm</b> is a emulator for a 32-bit computer that aims to be 
            as powerful as a modern computer, but as simple as 8-bit computer
            from the 80s. This computer doesn't exist in a physical form 
            (<i>yet</i>).</p>
          <p>Features:</p>
          <ul>
            <li>32-bit CPU</li>
            <li>up to 4 Gb of RAM</li>
            <li>virtual memory</li>
            <li>up to 4 hard disks of 256 Gb each</li>
          </ul>
          <p>The tab "<i>doc</i>" contains the documentation for each one of the 
            computer devices on the left. The tab "<i>debug</i>" allows the 
            internals of each device to be inspected.</p>
          <p>The code for this emulator is avaliable under the
            <a href="LICENSE">GPLv3 license</a>.</p>
        </section>

        <section id="not_avaliable">Not avaliable.</section>

        <!--             -->
        <!-- MOTHERBOARD -->
        <!--             -->

        <section id="mboard_doc">
          <h2>Motherboard</h2>
          <p>The <b>motherboard</b> coordinates how the memory is accessed. Each <b>device</b>
            contains an addressing area, and the motherboard will relay the information
            to the device, according to the address.</p>
          <p>The addressing areas are organized in a <b>memory map</b>.</p>
          <p>The full physical memory of the computer (<b>RAM</b>) is also present
            in the motherboard. When a memory address is accessed, the motherboard will:</p>
          <ol>
            <li>look for a device in the memory map. If no device is mapped to this address, it will</li>
            <li>ask the MMU for a physical address. If the MMU is not active, it will</li>
            <li>access the physical address in RAM. If the address is out of bounds, it will</li>
            <li>set the <b>OB</b> (<i>out of bounds</i>) register. This register can be accessed
              at 0xFFFFFFFF.</li>
          </ol>
          <p>This means that, without a MMU active, the memory map will look like this:</p>
          <table class="mmap">
            <tr>
              <td class="area ram">RAM (physical memory)</td>
              <td class="beginning"></td>
              <td class="address">0x00000000</td>
            </tr>
            <tr>
              <td class="area invalid">Invalid access area</td>
              <td class="beginning"></td>
              <td class="address">?? (depending on memory size)</td>
            </tr>
            <tr>
              <td class="area devreg">Devices registers</td>
              <td class="beginning"></td>
              <td class="address">0xF0000000</td>
            </tr>
            <tr>
              <td class="area devram">Devices RAM</td>
              <td class="beginning"></td>
              <td class="address">0xF0010000</td>
            </tr>
            <tr>
              <td class="area ob">OB</td>
              <td class="beginning"></td>
              <td class="address">0xFFFFFFFF</td>
            </tr>
          </table>

          <h2>Implementing new devices</h2>
          <p>New devices can be created in javascript and connected to the motherboard.
            For that, they need to respect the following interface:</p>
          <pre class="code">
class Device {
    constructor(interrupts...)
    name()            : string
    interruptCount()  : int         [optional]
    get(addr)         : uint8_t
    set(addr, uint_8)
    doc()             : html_string [optional]
    debug()           : html_string [optional]
}
          </pre>
          <p>Devices of this kind will receive 256 bytes of area to use as registers.</p>
          <p>Devices can also request an extra, larger amount of memory
             to be used as a local RAM. These devices need to respect the following interface:</p>
          <pre class="code">
class RAMDevice extends Device {
    areaRequested() : int
    getRAM(addr)    : uint8_t
    setRAM(addr, uint8_t)
} 
          </pre>
          <p>The MMU is a special kind of devices that manages virtual memory
             addresses. There can be only one MMU attached to the motherboard,
             and it follows this interface:</p>
          <pre class="code">
class MMU extends Device {
    translate(uint32_t) : uint32_t
}
          </pre>
        </section>

        <section id="mboard_debug">

          <h2>Memory map</h2>
          <section id="mmap"></section>

          <h2>Registers</h2>
          <section id="registers">
            <table>
              <tr>
                <th>Register</th>
                <th>Description</th>
                <th>Address</th>
                <th>Current value</th>
              </tr>
              <tr>
                <td>OB</td>
                <td>
                  Set to 1 when an access was made to a memory address outside of bounds.
                  Needs to be reset manually.
                </td>
                <td>0xFFFFFFFF</td>
                <td><span class="memory_data">0xFFFFFFFF,rw</span></td>
              </tr>
            </table>
          </section>

          <!--
          <h2>Physical memory</h2>
          <section id="phmem"></section>
          -->
        </section>

        <section id="mboard_test">
          <button class="test" onclick="(new Motherboard(4, true)).runTests('mboard_tests');">Run tests</button>
          <section id="mboard_tests"></section>
        </section>

      </section>

    </section>


    <footer>
      <hr>
      Released under the <a href="LICENSE">GPLv3 license</a>.<br>
      Tested on the latest versions of
      <a href="https://www.google.com/chrome/">Google Chrome</a> and
      <a href="https://www.mozilla.org/firefox/">Mozilla Firefox</a>.
    </footer>
  </body>
</html>

<!-- vim: ts=2:sw=2:sts=2:expandtab
-->
